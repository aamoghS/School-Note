<!DOCTYPE html>
<html>
<head>
  <title>Chapter 15</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h1>Title Chapter 15</h1>

  <h2>15.1 Linear Collections with a Restricted Set of Operations and Examples of Stack, Queue, and Priority Queue</h2>

  <p>Stacks are linear collections in which access is restricted to one end, the top.</p>
  <p>An example of a stack is a tray of plates; they are taken and added to the top rather than the bottom.</p>
  <p>Stacks use the last-in, first-out protocol (LIFO).</p>

  <p>Operations for putting items on and removing them from the stack are called push and pop, respectively.</p>
  <p><em>Push</em> - add to the top | <em>Pop</em> - removed from the top</p>

  <p>Other examples are PEZ dispensers, adding papers to the top of the pile.</p>

  <h2>The Stack Class</h2>

  <p>The java.util package has the Stack class, which is a subclass of Vector.</p>
  <p>Vector implements the List and Collections interface.</p>

  <p><strong>Methods:</strong></p>
  <ul>
    <li><code>Boolean empty()</code> - returns true if the stack is empty or false otherwise</li>
    <li><code>E peek()</code> - under the assumption that the stack is not empty, it would return the object at the top of the stack. If the stack is empty, then it will throw EmptyStackException.</li>
    <li><code>E pop()</code> - under the assumption that the stack is not empty, it would return the object at the top of the stack and remove it from the top. If the stack is empty, then it will throw EmptyStackException.</li>
    <li><code>void push(E Element)</code> - adds an element to the top of the stack</li>
    <li><code>int size()</code> - returns the number of objects on the stack</li>
  </ul>

  <p>Stacks are generic collections, so their element types should be specified when created. For example:</p>
  <pre><code>Stack&lt;String&gt; stk = new Stack&lt;String&gt;();</code></pre>

  <h2>Application of Stacks</h2>

  <p>The application of stacks in computer science is numerous:</p>
  <ul>
    <li>Parsing expressions in context-free programming languages is a problem in compiler design.</li>
    <li>Translating the infix expression to postfix and evaluating the postfix expression.</li>
    <li>Backtracking algorithms, such as automated theorem proving and game-playing.</li>
  </ul>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>Managing Computer Memory in Support of Method Class</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h1>Managing Computer Memory in Support of Method Class</h1>

  <p>Supports the "undo" feature in editors, word processors, spreadsheet and drawing programs, and similar applications.</p>
  <p>Maintained a history of the links visited by a web browser.</p>

  <h2>Evaluating Arithmetic Expressions</h2>

  <p>We translate the infix to postfix and then evaluate the postfix form.</p>
  <p>For infix, the operator is located between its operand while postfix has an operator immediately following its operand.</p>
  <p>Both formats have operands that appear in the same order while the operators do not.</p>
  <p>Infix form requires parentheses while postfix never does.</p>
  <p>Infix evaluation involves the rule of precedence while postfix applies operators as soon as they are encountered.</p>

  <h2>Evaluating Postfix Expression</h2>

  <ol>
    <li>Scan across the expression from left to right.</li>
    <li>On encountering an operator, apply it to the two preceding operands and replace all three with the result.</li>
    <li>Continue scanning until it reaches the expression's end, at which point only the expression's value remains.</li>
  </ol>

  <p>Token refers to an operand or operator in the algorithm made to analyze the expression.</p>
  <p>The time complexity of the algorithm is O(n), where n is the number of tokens in the expression.</p>

  <h2>Transforming Infix to Postfix</h2>

  <p>Multiplication and division have a higher precedence than addition and subtraction, except parentheses.</p>

  <ol start="1">
    <li>Start with an empty postfix expression and an empty stack, which will hold operators and left parentheses.</li>
    <li>Scan across the infix from left to right.</li>
    <li>On encountering an operand, append it to the postfix expression.</li>
  </ol>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>Transforming Infix to Postfix</title>
</head>
<body style="font-family: 'Times New Roman';">
  <ol start="4">
    <li>On encountering an operator, pop off the stack all operators that have equal or higher precedence and append them to the postfix.</li>
    <li>When left parenthesis, push it to the stack.</li>
    <li>On encountering a right parenthesis, shift operators from the stack to the postfix expression until meeting the matching left parenthesis, which is discarded.</li>
    <li>On encountering the end of the infix expression, transfer the remaining operators from the stack to the postfix expression.</li>
  </ol>

  <h2>Backtracking</h2>

  <p>When implementing backtracking algorithms,</p>
  <p>One would use a stack while others use recursions.</p>
  <p>Backtracking algorithm begins with a predefined starting state then moves from state to state in search of the desired ending state.</p>
  <p>At any point, when there is a choice of several alternative states, the algorithm picks one that is random and then continues.</p>
  <p>If the algorithm reaches a state of an undesirable outcome, then it will back up to the last point where there was an unexplored alternative.</p>
  <p>The algorithm would exhaustively search all states or reach the end of the state.</p>
  <p>For the algorithm, the two things that are missing are,</p>
  <p>The complexity of deciding if a state has been visited.</p>
  <p>The complexity of listing states adjacent to a given state.</p>
  <p>If we assume processes are O(1), then the algorithm as a whole is O(n) where n is the total number of states.</p>

  <h2>Memory Management</h2>

  <p>During execution, the code and data occupy the memory.</p>
  <p>Java compiler translates a Java program into bytecode.</p>
  <p>A complex program is called JVM and then executes these.</p>
  <p>The memory or runtime is controlled by the JVM divided into 6 sections:</p>
  <ul>
    <li>Object Heap</li>
    <li>Unused Memory</li>
    <li>Call Stack</li>
    <li>Static Variable</li>
    <li>Program</li>
    <li>Java Virtual Machine</li>
  </ul>

  <p>Java Virtual Machine executes a Java program, and this is internal to the JVM and has two variables which are locationCounter and basePtr.</p>
  <p>The location Counter points at the instruction the JVM will execute next.</p>
  <p>The basePtr points at the top activation record's base.</p>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>Byte Code and Program Components</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h2>Byte Code for All Methods of Our Program</h2>
  <p>The p+rogram static variables</p>

  <h2>Call Stack</h2>
  <p>Every time a method is called, an activation record is created and pushed onto the call stack.</p>
  <p>When a method finishes execution and returns control to the method that called it, the activation record is popped off the stack.</p>
  <p>At the bottom of the stack, the activation record for the method main is located.</p>

  <h2>Unused Memory</h2>
  <p>The region's size grows and shrinks in response to the demand of the call stack and the object heap.</p>

  <h2>Object Heap</h2>
  <p>All objects are in the region called the heap.</p>
  <p>When an object is instantiated, the JVM must find space for the object on the heap.</p>
  <p>When no longer needed, the JVM garbage collector recovers the space for further use.</p>
  <p>When low on space, the heap extends into Unused Memory.</p>

  <h2>Local Variables and Parameters</h2>
  <p>Local variables and parameters hold data needed by executing methods.</p>
  <p>The remaining regions hold data that allows the JVM to pass control backward from the currently executing method to the method that was called.</p>

  <h2>When a Method is Called in JVM</h2>
  <ul>
    <li>Create the method activation record and push it onto the call stack.</li>
    <li>Save the basePtr's value labeled Prev basePtr and set basePtr to the new record base.</li>
    <li>Save the locationCounter's current value labeled Return Address and set locationCounter to the first instruction of the called method.</li>
    <li>Copies the calling parameters into regions labeled parameters.</li>
    <li>Initializes local variables as required.</li>
    <li>Start executing the called method at the location indicated by locationCounter.</li>
  </ul>
  <p>When executing, the local and parameters activation records are referenced by adding an offset to the basePtr.</p>
  <p>The local variables and parameters can be accessed anywhere in the activation record if basePtr has been initialized.</p>

  <h2>Before Returning, the Method Stores Its Return Value</h2>
  <p>The value can be a reference to an object or can be a primitive data type or character.</p>

  <h2>When the Method Has Finished Executing, the JVM</h2>
  <p>(Details of what the JVM does after the method has finished executing would be provided here.)</p>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>Implementing Stacks and Analyzing Performance</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h2>1. Reestablishing the Settings Needed by the Calling Method</h2>
  <p>1. Reestablishes the settings needed by the calling method by restoring values of the locationCounter and basePtr from values stored in the activation record.</p>
  <p>2. Pop the activation record from the call stack.</p>
  <p>3. Resume execution of the calling method at the location indicated by locationCounter.</p>

  <h2>Implementing Stacks</h2>
  <p>Stacks are linear collections, and natural choices for implementation are based on arrays and linked structures.</p>
  <p>The Stack class of java.util extends Vector, which in turn uses an array.</p>

  <h2>Analyzing the Performance of Stack Implementation</h2>
  <p>The run-time performance of stack implementation depends on the run-time performance of operations on the data structures contained in it.</p>
  <p>The two options are arrays and linked structures.</p>
  <p>A stack that uses an array list or an array can pop or push elements in constant time, with one exception.</p>
  <p>When the underlying array runs out of room, it must be resized, and this operation takes linear time.</p>
  <p>Elements can always be added to the end or beginning of a linked structure in constant time.</p>
  <p>Linked structure requires three times the memory to represent links and references to data but no extra memory to represent the data themselves.</p>
  <p>Linked implementation is usually preferable.</p>

  <h2>The String Tokenizer Class (15.2)</h2>
  <p>String Tokenizer is inside the java.util package, which allows you to break a string into individual tokens using default delimiters or programmer-specific delimiters.</p>
  <p>The process of obtaining tokens from a string tokenizer is called scanning.</p>
  <p>Punctuation marks are treated no differently than letters.</p>

  <h2>Queues and Priority Queues (15.3)</h2>
  <p>Insertions in a queue are restricted to one end, called the rear, and removals are restricted to the other end, called the front.</p>
  <p>Queue supports the first-in, first-out protocol.</p>
  <p>Queues are in everyday life and occur in any situation where people or things are lined up for processing on a first-come, first-served basis.</p>
  <p>Queues have "add," which adds an item to the rear of a queue, and "remove," which removes an item from the front.</p>
  <p>The original names are "enqueue" and "dequeue."</p>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>Queue Interface and Applications</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h2>Queue is Empty at First</h2>
  <p>Related to queues is an ADT called a priority queue.</p>
  <p>In a queue, the item removed or served next is always the item that has been waiting the longest.</p>
  <ul>
    <li>CPU access - processes are queued for access to shared CPU.</li>
    <li>Disk access - processes are queued for access to a shared secondary storage device.</li>
    <li>Printer access - Print jobs are queued for access to a shared printer.</li>
  </ul>

  <h2>Process Scheduling</h2>
  <p>Process scheduling can be used in simple or priority queues.</p>

  <h2>The Queue Interface and Implementation</h2>
  <p>The queue interface extends the collection interface.</p>

  <h2>Application of Queues</h2>
  <p>One application is computer simulations, and the other is round-robin CPU scheduling.</p>
  
  <h3>Simulations</h3>
  <p>Computer simulations study the behavior of real-world systems, specifically impractical or dangerous ones.</p>
  <p>For example, simulating traffic on a busy highway.</p>
  <p>The outputs can include the total number of vehicles moving between two points.</p>

  <p>The second example is the manager of a supermarket.</p>
  <p>Issues include:</p>
  <ul>
    <li>Frequency with which new customers arrive.</li>
    <li>Number of checkout clerks available.</li>
    <li>The number of items in a customer's shopping cart.</li>
    <li>The period of time considered.</li>
  </ul>
  <p>The factors can be put in a simulation, and it can determine the total customers processed. Adding input that quantifies efficiency can help determine cost-effectiveness.</p>

  <p>Simulation programs avoid the need for formulas by imitating the actual situation and collecting pertinent statistics.</p>
  <p>They can also be used for a simple technique to mimic variability, where each input causes the results to change slightly, enhancing the realism of the simulation.</p>
  <p>Simulation operates by manipulating queues, adding and removing. The program accumulates statistics.</p>
</body>
</html>


<!DOCTYPE html>
<html>
<head>
  <title>Priority Queue and Sorted List Implementation</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h2>Priority Queue</h2>
  <p>Priority Queue maintains a natural order among the elements and implements the Queue interface.</p>
  <p>A PriorityQueue can contain strings or integers but not stacks or random number generators.</p>
  <p>Example: `PriorityQueue<String> queue = new PriorityQueue<String>();`</p>
  <p>The PriorityQueue class uses a heap implementation, but this implementation does not guarantee FIFO for elements with the same priority.</p>
  <p>The second implementation is the natural ordering of elements and guarantees FIFO in cases where elements have the same priority.</p>

  <h2>Sorted List Implementation of a Priority Queue</h2>
  <p>A sorted list is a list of comparable elements that are maintained in natural order.</p>
  <p>The priority queue list is arranged so that the minimum element is accessed at or removed from one end of the list.</p>
  <p>If ordered properly, then the linked list will work well if we remove the minimum element from the head or tail.</p>
  <p>If an element is greater than or equal to a given element, then the new element can be inserted before the given element.</p>
  <p>This gives the FIFO ordering and priorities, but elements must be in descending order of the list, and elements will be peeked or removed from the tail position.</p>

  <p>The "add" operation is one that needs development in a priority queue.</p>
  <p>The operation searches for the element in the proper place in the list and then inserts it.</p>
  <p>The search starts at the end and goes until the new element is greater than or equal to the existing element.</p>
  <p>The new element is inserted at the determined position.</p>
  <p>If the search runs off the tail, the element becomes the new minimum and is placed at the tail.</p>

  <p>TrueLinkedPriorityQueue is a priority queue.</p>
  <p>It implements the TrueQueue interface and has a linked list. The implementation of every method, except for "add," is the same in the two classes.</p>
  <p>TrueLinkedPriorityQueue is a subclass of TrueLinkedQueue.</p>

  <p>Notes about the implementation:</p>
  <ol>
    <li>The heading of the class is not merely the variable but the expression `E extends Comparable<E>`. Any element type used in the collection implements the Comparable interface.</li>
    <li>The element type of the superclass is specified by the simple variable `E`, and it can contain the type of elements that implement Comparable.</li>
    <li>As the element type is restricted, the code for the "add" method does not have to cast the element to Comparable before sending it to compareTo.</li>
    <li>The expression `Comparable<E>` indicates generic comparable.</li>
  </ol>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>Using Comparable Interface with Generic Collections</title>
</head>
<body style="font-family: 'Times New Roman';">
  <h2>Using Comparable Interface with Generic Collections</h2>
  <p>The version of `compareTo` in the `TrueLinkedPriorityQueue` is different in two ways than the technical use of an array of objects:</p>
  <ol>
    <li>The receiver object is not cast to `Comparable` as it is already comparable.</li>
    <li>The parameter object must be of the collection's element type (i.e., comparable).</li>
  </ol>

  <p>As `compareTo` is in the context of a generic collection, the signature of the method should be generic. This leads to any elements using the generic version of the `Comparable` interface.</p>

  <p>Element types are candidates for inclusion. Several classes already implement the generic `Comparable`.</p>
  <p>It is possible to make a "raw" `Comparable`, but the generic version is preferred because it is safer and easier to use.</p>
</body>
</html>
