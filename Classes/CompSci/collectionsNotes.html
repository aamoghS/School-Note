<!DOCTYPE html>
<html>

<head>
    <style>
        /* Add some styling if desired */
        strong {
            font-weight: bold;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 15px;
        }
        em {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <h1><strong>Collections</strong></h1>

    <p><strong>Collections</strong> - a group of items that we treat as a conceptual argument in non-trivial software.</p>

    <p><strong>Types of collections</strong>:</p>
    <ul>
        <li><strong>String</strong></li>
        <li><strong>Stack</strong></li>
        <li><strong>List</strong></li>
        <li><strong>Queue</strong></li>
        <li><strong>Binary Tree</strong></li>
        <li><strong>Heap</strong></li>
        <li><strong>Graph</strong></li>
        <li><strong>Map</strong></li>
        <li><strong>Set</strong></li>
        <li><strong>Bag</strong></li>
    </ul>

    <p>Collections can be <strong>homogeneous</strong> (all items of the same type) or <em>heterogeneous</em> (items of different types).</p>
    <p>Arrays are homogeneous.</p>

    <p>There are <strong>four categories</strong> of collections:</p>
    <ul>
        <li><strong>Linear Collection:</strong> Each item except the first has a unique predecessor. Each item except the last has a unique successor. Ends with a null. Linear Collection examples: Grocery List, Stack of dinner plates.</li>
        <li><strong>Hierarchical Collection:</strong> Structured as an upside-down tree. Each data has a predecessor except for the top, which is the parent. Can have multiple successors. Example: Binary Tree, Company Organization tree, book table of content.</li>
        <li><strong>Graph Collections:</strong> Data items can have many predecessors or any successor. Example: Map of airline routes between cities.</li>
        <li><strong>Unordered Collection:</strong> Data is not in any order, and you cannot meaningfully speak of an item’s predecessor or successor. Example: A bag of marbles.</li>
    </ul>

    <p><em>Collections are dynamic rather than static</em> - they can grow or shrink with the needs of a problem, and their contents change over time.</p>
  <p><strong>Manipulations that can be performed on a collection</strong> vary with the type of collection.</p>
    <p><strong>Operations:</strong></p>
    <ul>
        <li><em>Search and retrieval</em> - search collection for target at a position. Gives the value or position returned, if not found then null or “-1”.</li>
        <li><em>Removal</em> - deletes item at a given position or given item.</li>
        <li><em>Insertion</em> - adds an item to the collection at a particular position.</li>
        <li><em>Replacement</em> - combines removal and insertion in a single operation.</li>
        <li><em>Traversal</em> - visits each item in the collection. Items can be accessed or modified, allowing insertion or removal, and many more.</li>
    </ul>

    <p><strong>Abstraction is a collection</strong>:</p>
    <p><strong>Abstract data types</strong> - the collection consists of data organized. From a user perspective, a collection is an abstraction. Developers of collections are concerned with implementing collection behavior with the goal of achieving the best performance.</p>
    <p><em>Abstraction is not unique to the discussion of collections</em>. For example, a house is an abstraction of a physical house, allowing us to focus on structural elements.</p>
    
    <p>In computer science, <strong>abstraction</strong> is used to hide details.</p>

    <p>Java methods are the smallest unit, classes and user interfaces (UI) are next, and then packages are the largest.</p>

    <p><strong>Abstract Data Types</strong> are implemented as classes and UI.</p>

    <p><strong>Implementing collections</strong> based on space and accessing memory:</p>
    <ul>
        <li>Arrays</li>
        <li>Linear Linked Structures</li>
        <li>Other Linked Structures</li>
        <li>Hashing into an array</li>
    </ul>

    <p><strong>java.util</strong> uses three classes that implement the List interface:</p>
    <ul>
        <li>Linked List</li>
        <li>ArrayList</li>
        <li>Vector (orange man)</li>
    </ul>

    <p>Implementing a List:</p>
    <p><strong>List&lt;String&gt; lst = new LinkedList&lt;String&gt;();</strong> - similar to an array list.</p>

<p><strong>Java collections</strong> can be declared to contain specific types of objects.</p>

    <p><em>Primitive types</em> - Such as <strong>int</strong> have to be placed in a wrapper Object.</p>
    <p>Wrapped primitive values are automatically upboxed when accessed in the collection.</p>

    <p>Items coming from the collection are a specific type to the compiler but the item has to be cast to a specific type.</p>

    <p><strong>14.2 List</strong> - supports manipulation of items at any point of a linear collection.</p>
    
    <p><strong>Items in List are not always stored.</strong></p>
    <p>First item is head, and the last item is tail.</p>
    <p>Items retain their position over time. Addition affects predecessor, deletion affects predecessor.</p>

    <p><code>add(O)</code> - adds an object at the List tail.</p>
    <p><code>add(I, O)</code> - inserts an object at index <em>i</em>, where the first item is at index 0. Example: <em>The rest makes sense</em>.</p>

    <p>There is no standard operation for List.</p>

    <p>Index-Based operations manipulate items at designated positions within a List.</p>
    <p>List head- 0 runs to n-1, tail.</p>

    <p>List is sometimes called vectors or sequences, reminiscent of arrays in content of indexes.</p>

    <p><strong>Array</strong> is concrete data with specific and unvarying implementation based on a single block.</p>

<p><strong>List</strong> abstract data which can be represented in different ways. It also has a larger repertoire of basic operations. <em>Throw Index Out of Bounds Exception.</em></p>

    <p><strong>Content-based operations</strong> are based on the content of the List rather than the index.</p>
    <p><strong>Index-Based operations:</strong></p>
    <ul>
        <li><code>add(I, o)</code> - opens a slot at index <em>I</em> and inserts object <em>o</em> in the slot.</li>
        <li><code>get(i)</code> - returns the object at index <em>i</em>.</li>
    </ul>

    <p><strong>Content-Based operations:</strong></p>
    <ul>
        <li><code>contains(o)</code> - returns the object at index <em>i</em>.</li>
    </ul>

    <p>Position-based operations are performed relative to the established position in the list and utility (util). An <strong>Iterator</strong> is an object that allows a client to navigate through a list and perform various operations at the current position.</p>

    <p><code>java.util.List</code> has <strong>ArrayList</strong>, <strong>LinkedList</strong>, and <strong>Vector</strong> which implement the interface.</p>

    <p><code>indexOf(E element)</code> – returns the index in the list of the first occurrence.</p>

    <p><strong>Element type</strong> = type parameter. Tells the compiler to check for that element type.</p>
    <p><strong>Type variables</strong> such as <em>E</em>, <em>T</em>, <em>?</em> appear in the method signature.</p>

    <p><em>E</em> - symbol-type object must be the same as the element type of the collection. The two add methods expect only objects of the collection's element type as a parameter. <code>contains</code> and <code>removes</code> allow parameters of type object so the user can pass any objects of any class.</p>

    <p><strong>?</strong> - tells the computer that generic collections of any element type are allowed. <strong>T</strong> - type of supertype.</p>
    <p>Array shape can be built from a collection that contains different subtypes of shape.</p>

    <p>As linked list and array implement the <strong>List</strong> interface, they have the same logical behavior, though performance differs based on the chosen implementation.</p>
    <p><strong>ArrayList</strong> is faster for access and content-time. <strong>LinkedList</strong> is faster for insertions and content-time.</p>

<p><strong>Application of List:</strong></p>
    <p><strong>Linked List</strong> can manage free space in the object heap.</p>

    <p>Contiguous blocks of free space on heaps are limited by the free list.</p>
    <p>The problem with this is what to do when running into the garbage collector.</p>

    <p>The garbage collector identifies objects that are not referenced.</p>

    <p><strong>Files on Disk:</strong></p>
    <p>A computer file has three components:</p>
    <ul>
        <li>Directory</li>
        <li>Files</li>
        <li>Free space</li>
    </ul>

    <p>Disks are divided by concentric tracks, which are further divided by sections.</p>

    <p><em>Sector</em> is the smallest unit of information transferred. Similar to a linked list, ranging from 0 to n-1.</p>

    <p>Organized hierarchically, it does not experience fragmentation as spaces are allocated in sectors.</p>

    <p><strong>List</strong> is used to implement Abstract Data Types (ADTs) such as stacks and queues.</p>

    <p>Two ways to use List:</p>
    <ul>
        <li>Extend List class, creating a subclass.</li>
        <li>Create an instance within a new class.</li>
    </ul>

    <p>Extension is not wise.</p>

    <p><strong>ADTs</strong> - use List to inherit performance characteristics.</p>

    <p>Using List to implement makes coding easier.</p>

    <p>Iterator is the underlying list as a backing collection.</p>

    <p><strong>Iterator is:</strong></p>
    <ul>
        <li>Just before the first item</li>
        <li>Between two adjacent items</li>
    </ul>

<p><em>Just after the last item.</em></p>

    <p>When first instantiated, the position is before the first item.</p>

    <p><strong>Iterator</strong> interface - <code>java.util.Iterator</code></p>
    <p><code>Iterator&lt;String&gt; iter = listofStrings.iterator();</code></p>

    <p><strong>List</strong> serves as a backing store for the iterator.</p>
    <p>Backing store is the storage area.</p>

    <p><strong>Avoid:</strong></p>
    <ul>
        <li>Sending mutator messages to the backing list when the iterator is active.</li>
        <li>Sending <code>remove</code> to the iterator when the iterator is open.</li>
    </ul>

    <p>List iterator responds to the interface.</p>


</body>

</html>
