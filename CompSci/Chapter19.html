<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h1 {
      font-size: 24px;
      font-weight: bold;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <h1>Chapter 19</h1>
  <p>A major category of collections is called “hierarchical” consists of various tree structures. They have no standard set of operations and most languages do not include them. The primary use is in implementation in other collections that require efficient searching.</p>

  <h2>Chapter 19.1</h2>
  <p>Trees that each item can have multiple successors, and all items except a privileged item called the root have one predecessor.</p>
  <p>A parse tree describes syntactic structure of sentence in terms of component parts.</p>
  <p>The items are called nodes, and the trees are drawn with the root at the top. Below a node and connected by lines is a successor or children. A node without children is called a leaf. Above a node is its predecessor or parent. A root cannot have a parent but children, while a leaf can have a parent but no kids. A node that has children is called an interior node.</p>

  <p>Book table of contents is another example of a hierarchical collection. Trees are used to organize computer file systems and remind to view files on a hard drive.</p>

  <h2>Subtitle Talking About Trees</h2>
  <p><strong>Node:</strong> An item stored in a tree</p>
  <p><strong>Root:</strong> The topmost node in a tree; It is the only node without a predecessor or parent.</p>
  <p><strong>Child:</strong> A successor of a node; A node can have more than one child, and its children are viewed as organized in left-to-right order. The leftmost child is called the first child, and the rightmost is the last child.</p>
  <p><strong>Parent:</strong> The predecessor of a node; A node can have only one parent.</p>
  <p><strong>Siblings:</strong> The children of a common parent</p>
  <p><strong>Edge/Branch:</strong> The line that connects a parent to its child</p>
  <p><strong>Descendant:</strong> A node's descendants include its children, its children's children, and so on, down to the leaves.</p>
  <p><strong>Ancestor:</strong> A node's ancestors include its parent, its parent's parent, and so on, up to the root.</p>
  <p><strong>Path:</strong> The sequence of edges that connect a node and one of its descendants</p>
  <p><strong>Path Length:</strong> The number of edges in a path</p>
  <p><strong>Leaf:</strong> A node that has no children</p>
  <p><strong>Interior Node:</strong> A node that has at least one child</p>
  <p><strong>Depth or Level:</strong> The depth or level of a node equals the length of the path connecting it to the root. Thus, the root depth or level of the root is 0. Its children are at level 1, and so on.</p>
  <p><strong>Height:</strong> The height of a tree equals the length of the longest path in the tree, or put differently, the maximum level number among all nodes.</p>
  <p><strong>Subtree:</strong> The tree formed by considering a node and all its descendants; We exclude the root when forming subtrees.</p>

</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Subtitle: General Trees and Binary Tree</h2>
  <p>The general trees are the ones with one root, then parents, and leaves. A binary tree is each node with at most two children, such as the left and right child. When a node only has one child in a binary tree, it is either the right or left.</p>

  <h2>Subtitle: Recursive Definition of Trees</h2>
  <p>A general tree is empty or consists of a finite set of nodes T. One node ‘r’ is distinguished from others called the root. T –{r} is partitioned into subsets, which is a general tree.</p>

  <h2>Subtitle: Recursive Definition of Binary Tree</h2>
  <p>A binary tree is empty or consists of a root plus a left subtree and a right subtree.</p>

  <h2>Title: Complete Binary Tree</h2>
  <p>Trees in data structure vary in size. A complete binary tree gives optimal balance to the "bushiness" of a binary tree. A binary tree is complete if each level has a complete complement of nodes, and nodes are filled from the left. Complete or near-complete trees are desirable as they support efficient searching, insertions, and removals.</p>

  <h2>Title: Full Binary Trees</h2>
  <p>A full binary tree contains the maximum number of nodes for its height. Each node is either an interior node with two non-empty children or a leaf. Leaves in a full binary tree are greater than the number of interior nodes. A full binary tree has the minimum height necessary to accommodate a given number of nodes, making them fully balanced. Fully balanced trees can accommodate 2^d - 1 nodes. There can be 2n nodes in n levels. The height of n nodes is log₂(n).</p>

  <h2>Title: Heaps</h2>
  <p>Heaps in a binary tree where each node is less than or equal to both of its children. Constraints on the order of nodes are the heap property. The smallest item is the root node, while the largest is in the leaves. The arrangement of data in heaps supports efficient sorting called heap sort and implements priority queues.</p>

  <h2>Title: Expression Trees</h2>
  <p>To process expressions is to build a data structure called a parse tree.</p>

  <h2>Title: Binary Search Trees</h2>
  <p>A call tree for a binary tree can reduce the search space by one half when the array is sorted. The efficiency of search depends on the shape of the tree. Everything depends on how the data come into the tree and how it's sorted.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Subtitle: Binary Tree Traversal</h2>
  <p>There are 4 types of traversal for binary trees: preorder, inorder, postorder, and level order. Each type of traversal follows a particular path and direction.</p>

  <h3>Subtitle: Preorder Traversal</h3>
  <p>Visits the root node then traverses the left subtree and right subtree.</p>

  <h3>Subtitle: Inorder Traversal</h3>
  <p>Inorder traversal algorithm traverses the left subtree, visits the root node, and traverses the right subtree.</p>

  <h3>Subtitle: Postorder Traversal</h3>
  <p>Postorder traversal algorithm traverses the left subtree, then the right subtree, and visits the root node.</p>

  <h3>Subtitle: Level Order Traversal</h3>
  <p>Level order visits the nodes at each level from left to right.</p>

  <h3>Subtitle: Conclusion</h3>
  <p>Preorder, inorder, and postorder traversals of an expression tree can be used to generate representations of expressions, respectively.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Subtitle: Linked Implementation of Binary Trees</h2>
  <p>Two implementations of binary trees use arrays and linked structures.</p>

  <p>The interface for a binary tree includes methods needed to implement sorted sets and maps. The element type should implement comparable. Search trees also support different traversal methods, which are coded in BSTPT.</p>

  <h3>Methods</h3>
  <ul>
    <li><strong>E add(E obj):</strong> If the element is not already in the tree, then adds the element to the tree, increasing the tree's size by one, and returns null; otherwise, replaces the old element with the new one and returns the old element.</li>
    <li><strong>E contains(E obj):</strong> Returns the node's value if the element is in the tree, else null.</li>
    <li><strong>boolean isEmpty():</strong> Returns true if the tree contains no elements, else false.</li>
    <li><strong>Iterator&lt;E&gt; iterator():</strong> Returns an iterator on the tree; The iterator allows the client to visit the elements in alphabetical order. The tree is not used as a backing store, so the method remove has no effect.</li>
    <li><strong>List&lt;E&gt; inorderTraverse():</strong> Returns a list that contains the results of an inorder traversal of the tree.</li>
    <li><strong>List&lt;E&gt; levelorderTraverse():</strong> Returns a list that contains the results of a level-order traversal of the tree.</li>
    <li><strong>List&lt;E&gt; postorderTraverse():</strong> Returns a list that contains the results of a postorder traversal of the tree.</li>
    <li><strong>List&lt;E&gt; preorderTraverse():</strong> Returns a list that contains the results of a preorder traversal of the tree.</li>
    <li><strong>E remove(E obj):</strong> If the element is in the tree, removes it and returns the node's value; otherwise, returns null.</li>
    <li><strong>int size():</strong> Returns the number of elements in the tree.</li>
    <li><strong>String toString():</strong> Returns a string containing the string representations of the elements in a format that shows the tree structure.</li>
  </ul>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: The Class LinkedBSTPT</h2>
  <p>Linked implementation of a binary search tree has external pointers at the root node. Each node contains an element and links to the left and right subtrees.</p>
  <p>BSPST is generic and is implemented in LinkedBSPST.</p>

  <h2>Title: Inserting an Item into a Binary Search Tree</h2>
  <p>The add method inserts an object into the proper place in a binary search tree. The method implements sorted sets and maps while replacing duplicate items with new ones and returning the old ones. An item's proper place will either be the root node or the leaf node to the left of the item's natural successor or to the right of the item's natural predecessor. It does this by using compareTo.</p>
  <p>All items must implement the Comparable interface. The add method uses a loop to advance until the correct pointer is found.</p>

  <h2>Title: Searching a Binary Search Tree</h2>
  <p>The contains method returns the node value if the object is in the tree; otherwise, it gives null. A recursive strategy takes advantage of the nodes.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: Traversals and the Iterator</h2>
  <p>Each traversal can use a recursive strategy and implement a pair of methods which builds and returns a list of items accumulated.</p>

  <h3>Inorder Traversal</h3>
  <ol>
    <li>Private method <strong>inorderTraverse</strong> expects an empty list and a tree’s root node as parameters and adds the items from an inorder traversal to the list.</li>
    <li>The public method <strong>inorderTraverse</strong> returns a list of items accumulated from an inorder traversal of the tree.</li>
  </ol>

  <h3>Title: Level-Order Traversal</h3>
  <p>The algorithm for level-order starts at level 0. It will visit each node from left to right then repeat for the next level until all nodes are visited. A convenient way to schedule nodes to be visited is on a queue.</p>
  <p>Top-level public method <strong>levelorderTraverse</strong> creates a queue and a list; the queue is for scheduling and the list is to return to the client. The method places the root at the front of the queue and passes collections to the helper method levelorderTraverse.</p>
  <p>The recursive pattern for level-order traversal removes a node for processing in the queue and then adds the left and right subtrees to the queue before the recursive call. The order in subtrees being enqueued determines the order for processing as it moves across the levels of the tree.</p>

  <h3>Title: Iterator</h3>
  <p>Clients using a binary search tree to implement sorted sets and maps prefer to have an iterator method that allows them to visit items in alphabetical order.</p>
  <p>The iterator method for a binary search tree returns an iterator on a list that results from an inorder traversal. The remove method of the iterator has no effect on the tree, as the iterator is the backing store of the tree, not the list.</p>
  <p>As the <strong>LinkedBSPST</strong> class implements the <strong>Iterable</strong> interface, the program can use an enhanced for loop for the inorder traversal of the binary search tree.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: toString</h2>
  <p>The toString method can implement any traversal. A convenient way is to “rotate” the tree between interior nodes.</p>

  <h2>Title: Removing an Item from a Binary Search Tree</h2>
  <ol>
    <li>Save a pointer to the root node.</li>
    <li>Attempt to locate the node to be removed, its parent, and its parent's pointer to this node.</li>
    <li>If the item is not in the tree, return false.</li>
    <li>Otherwise, if the node has a left child and a right child, replace the node's value with the largest value in the left subtree and delete that value's node from the left subtree.</li>
    <li>Otherwise, set the parent's pointer to the node to the node's only child.</li>
    <li>Reset the root node to the saved pointer.</li>
    <li>Decrement the size and return true.</li>
  </ol>
  <p>Step 4 in this process is fairly complex, so it can be factored out into a helper method, which takes the node to be deleted as a parameter. The outline for this method follows (we refer to the node containing the item to be removed as the top node):</p>
  <ol>
    <li>Search the top node's left subtree for the node containing the largest item. This will be in the rightmost node of the subtree. Be sure to track the parent of the current node during the search.</li>
    <li>Replace the top node's value with the item.</li>
    <li>If the top node's left child contained the largest item (e.g., that node had no right subtree, so the parent pointer still refers to the top node), set the top node's left child pointer to its left child's left child pointer.</li>
    <li>Otherwise, set the parent node's right child pointer to that right child's left child pointer.</li>
  </ol>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: Complexity Analysis of Binary Search Trees</h2>
  <p>Binary Search Trees replicate O(logn). Optimal behavior depends on the shape of the tree. A bushy tree, one that is close to complete, supports close to logarithmic search. In the worst case, when items are inserted in alphabetical order, the shape is linear.</p>
  <p>The runtime of insertion also depends on the shape of the tree.</p>

  <h2>Title: 19.4 An Array Implementation of Binary Trees</h2>
  <p>An array-based implementation of a tree is possible but difficult to define and only in special situations.</p>
  <p>Mapping stacks, queues, and lists to an array is linear, and each element has an obvious predecessor and successor. Trees are hierarchical and resist being flattened.</p>

  <h3>Locations of Given Items in Array for a Complete Binary Tree</h3>
  <ul>
    <li><strong>Parent:</strong> (i-1) / 2</li>
    <li><strong>Left Sibling:</strong> i - 1</li>
    <li><strong>Right Sibling:</strong> i + 1</li>
    <li><strong>Left Child:</strong> i * 2 + 1</li>
    <li><strong>Right Child:</strong> i * 2 + 2</li>
  </ul>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: 19.5 Implementing Heaps</h2>
  <p>The Heap interface should recognize messages to return its size, add items, remove, and peek at items.</p>

  <h3>Methods in HeapPT</h3>
  <ul>
    <li><strong>boolean add(E obj):</strong> Inserts the element in its proper place in the heap, increasing the heap's size by one, and returns true.</li>
    <li><strong>Iterator&lt;E&gt; iterator():</strong> Returns an iterator on the heap; This iterator visits the items from the minimum to the maximum, and its remove method has no effect.</li>
    <li><strong>E peek():</strong> Precondition: The heap is not empty. Returns the element at the top of the heap.</li>
    <li><strong>E pop():</strong> Precondition: The heap is not empty. Removes and returns the topmost element in the heap.</li>
    <li><strong>int size():</strong> Returns the number of elements in the heap.</li>
  </ul>

  <p>Two critical operations are add and pop. The add operation expects comparable elements as parameters and inserts the element in the proper place in the heap. The place that is a level above is larger while below is smaller. Duplicate elements are placed below previously entered ones. The pop method deletes the topmost node and returns the element there. The peek operation returns but does not remove the topmost element in the heap.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: Implementing add and pop</h2>
  <p>The add and pop operations are also defined in <code>ArrayHeapPT</code>.</p>
  <p>Array implementation maintains the structure of the heap within an array.</p>

  <h3>For Insertion:</h3>
  <ol>
    <li>Begin by inserting the element at the bottom of the heap. In the array implementation, this will be in the position after the last element currently in the array.</li>
    <li>Then, enter a loop that "walks" the new element up the heap while the new element's value is less than that of its parent. Each time this relationship is true, we swap the new element with its parent. When this process stops (either the new element is greater than or equal to its parent or we have reached the top node), the new element is in its proper place.</li>
  </ol>

  <h3>For Removal:</h3>
  <ol>
    <li>Begin by saving pointers to the top element and the bottom element in the heap and by moving the element from the bottom to the top.</li>
    <li>Walk down the heap from the top, moving the smallest child up one level, until the bottom of the heap is reached.</li>
  </ol>

  <p>Number of comparisons for removal is log2(n), so pop is O(logn). Pop triggers half in the size of the underlying array, but its operation is O(n). Although amortized over all removals, it's O(1) per removal.</p>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Times New Roman', Times, serif;
    }

    h2 {
      font-size: 22px;
      font-weight: bold;
    }

    h3 {
      font-size: 20px;
      font-weight: bold;
    }

    p {
      font-size: 16px;
    }
  </style>
  <title>Chapter 19</title>
</head>

<body>

  <!-- Previous content -->

  <h2>Title: 19.6 Using a Heap to Implement a Priority Queue</h2>
  <p>A common implementation of a priority queue uses a heap. <code>java.util.PriorityQueue</code> is an implementation where items with the highest priority are near the top of the heap.</p>
  <p><code>HeapPriorityQueue</code> is based on the heap prototype.</p>

</body>

</html>

